--CREATE, INSERT-----------------------------------------------------------------------------------

DROP TABLE Many_to_many;
DROP TABLE Left_part;
DROP TABLE Right_part;

CREATE TABLE Left_part
(
pk               int GENERATED BY DEFAULT AS IDENTITY NOT NULL PRIMARY KEY,
byte_2           smallint,
byte_4           int,
true_false       number(1,0),
byte_4_8         float,
byte_4__         real,
YYYY_MM_DD       date,
fixed_length     char(10),
length           varchar(10),
fixed_length_rus nchar(10)
)

INSERT INTO Left_part (byte_2, byte_4,     true_false,    byte_4_8, byte_4__, YYYY_MM_DD,   fixed_length, length,  fixed_length_rus)
                SELECT 32767,  2147483647, 1,             1.2 as b, 3.4,      '13.09.2011', 'eeeeeeeeee', 'eeeee', 'уууууууууу' from dual union all 
                SELECT 32765,  2147483647, 1,             1.2 as b, 3.4,      '13.09.2011', 'eeeeeeeeee', 'eeeee', 'уууууууууу' from dual;

SELECT * from Left_part;

CREATE TABLE Right_part (
pk           int GENERATED BY DEFAULT AS IDENTITY NOT NULL PRIMARY KEY,
first_param  int,
second_param varchar(10),
third_param  date
);

INSERT INTO Right_part (first_param, second_param, third_param)
                SELECT  3,           'q',          '20.11.2024' FROM dual UNION ALL 
                SELECT  2,           'w',          '20.11.2024' FROM dual UNION ALL 
                SELECT  1,           'e',          '20.11.2024' FROM dual;

CREATE TABLE Many_to_many (
    pk       int GENERATED BY DEFAULT AS IDENTITY NOT NULL PRIMARY KEY,
    left_pk  int,
    right_pk int,
    CONSTRAINT left_pk  FOREIGN KEY (left_pk)  REFERENCES Left_part(pk)  ON DELETE CASCADE,
    CONSTRAINT right_pk FOREIGN KEY (right_pk) REFERENCES Right_part(pk) ON DELETE CASCADE
);

INSERT INTO Many_to_many (left_pk, right_pk) 
                   SELECT 1 a,     1 b FROM dual UNION ALL 
                   SELECT 2 a,     2 b FROM dual UNION ALL 
                   SELECT 2 a,     3 b FROM dual;

--VAR----------------------------------------------------------------------------------------------

SET SERVEROUTPUT ON;
DECLARE var int := 10;
BEGIN
    DBMS_OUTPUT.put_line(var);
END;

--SELECT-------------------------------------------------------------------------------------------

SELECT * FROM Left_part 
INNER JOIN Many_to_many
ON (Left_part.pk = Many_to_many.left_pk)
INNER JOIN Right_part
ON (Many_to_many.right_pk = Right_part.pk)
WHERE Left_part.pk = 2;

--UPDATE-------------------------------------------------------------------------------------------

UPDATE Left_part SET byte_2 = 32766 WHERE byte_2 = 32767;
SELECT * FROM Left_part;

--DELETE-------------------------------------------------------------------------------------------

DELETE FROM Left_part WHERE byte_2 = 32765;
SELECT * FROM Left_part;

--FUNCTION-----------------------------------------------------------------------------------------

CREATE OR REPLACE Function get_max_num
   (length_ IN varchar)
   RETURN int
IS
   result int;
BEGIN
   SELECT MAX(byte_4) INTO result
   FROM Left_part
   WHERE length = length_;
RETURN result;
END;

SET SERVEROUTPUT ON;
DECLARE var int;
BEGIN
   var:= get_max_num('eeeee');
   DBMS_OUTPUT.put_line(var);
END;

--PROCEDURE-----------------------------------------------------------------------------------------

CREATE OR REPLACE Procedure insert_conn_info
    (left_pk_ IN int, right_pk_ IN int)
IS
    result int;
BEGIN
    INSERT INTO Many_to_many (left_pk, right_pk) VALUES 
    (left_pk_, right_pk_);
END;

CALL insert_conn_info(1, 2);

--TRIGGER------------------------------------------------------------------------------------------

CREATE OR REPLACE
Function val
   RETURN int
IS
   result int;
BEGIN
   SELECT "ISEQ$$_77278".currval INTO result
   FROM dual;
RETURN result;
END;

CREATE OR REPLACE Package package_name
IS
  updated boolean;
  Procedure update_table;  
END package_name;
/

CREATE OR REPLACE Package body package_name
IS
  Procedure update_table
  IS
  BEGIN
    IF updated THEN
      updated := false;
    UPDATE Right_part
    SET first_param = 30
    WHERE pk = val();
    DBMS_OUTPUT.put_line(val());
    END IF;
  END;  
END package_name;
/

CREATE OR REPLACE trigger trigger_before_insert
BEFORE INSERT
ON Right_part
FOR EACH ROW
BEGIN
   package_name.updated := true;  
END trigger_before_insert; 
/

CREATE OR REPLACE trigger trigger_after_insert
AFTER INSERT
ON Right_part
BEGIN
  package_name.updated;  
END trigger_after_insert;
/ 

INSERT INTO Right_part (second_param, third_param) VALUES 
('e', '20.11.2024');
SELECT * FROM Right_part
